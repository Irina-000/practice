#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <cmath>
#include <windows.h>
#include "ConWin.h"
#include <process.h>
#define _USE_MATH_DEFINES 
#define M_PI 3.14159265358979323846


using namespace std;
extern HDC hdc; // объявим  контекст устройства

HDC hdc;	// Объявим контекст устройства
            // Контекст устройства по сути это структура,
            // содержащая описание видеокарты на вашем компьютере
            // и всех необходимых графических элементов



// размеры окна для графика
const int kolvo = 200;

int main(int argc, const char* argv[])
{

    // **************************************************************************************************** //
    //                                          ЧТЕНИЕ ФАЙЛА                                                //
    // **************************************************************************************************** //


    string type;
    int ord;
    string ch_ord;

    cout << "choose type of file:\njust tests -j\n" << "without blowout -o \nwith blowout -w\n";
    cin >> type;
    while ((type != "-j") && (type != "-o") && (type != "-w"))
    {
        cout << "wrong type! try again\n";
        cin >> type;
    }

    cout << "enter number of file:";
    if (type == "-j")
    {
        cout << " between 1 and 20\n";
        cin >> ord;
        while ((ord <1) || (ord > 20))
        {
            cout << "wrong number! try again\n";
            cin >> ord;
        }

    }
    else if ((type == "-o") || (type == "-w"))
    {
        cout << " between 1 and 5\n";
        cin >> ord;
        while ((ord < 1) || (ord > 5))
        {
            cout << "wrong number! try again\n";
            cin >> ord;
        }

    }

    ch_ord = to_string(ord);

    string filename;
    filename = "C:\\Users\\User\\Desktop\\практика\\";
    if (type == "-j")
    {
        filename = filename + "просто_тесты\\" + ch_ord + ".txt";
    }
    else if (type == "-w")
    {
        filename = filename + "импульсы_с_выбросами\\" + ch_ord + ".txt";
    }
    else 
    {
        filename = filename + "импульсы_без_выбросов\\" + ch_ord + ".txt";
    }
    cout << filename << endl;

    ifstream inputFile(filename);
    //ifstream inputFile("C:\\Users\\User\\Desktop\\практика\\просто_тесты\\3.txt"); //чтение из файла
    //ifstream inputFile("C:\\Users\\User\\Desktop\\практика\\импульсы_с_выбросами\\1.txt"); //чтение из файла
    // если не существует этого файла
    if (!inputFile)
    {
        //вывод об ошибке
        cerr << "Error! Not exist!" << endl;
        return 1;
    }


    string test;
    getline(inputFile, test);                   //перенос всего содержимого в одну строку
    inputFile.close();                          //закрытие файла

    // Удаляем скобки
    // если первым символом явдяется скобка
    if (test.front() == '[')
    {
        test.erase(0, 1);
    }
    // если последним символом явдяется скобка
    if (test.back() == ']')
    {
        test.pop_back();
    }

    vector<double> num;                         // вектор истинных чисел
    vector<double> numbers;                     // вектор удобных чисел
    stringstream str(test);                     // переменная для перевода строки в набор чисел
    string number;

    while (getline(str, number, ','))           // вычленение чисел из строки, разделённых запятой
    {
        // добавление нового числа в конец вектора чисел
        numbers.push_back(stod(number));
    }

    int count = numbers.size();
    int i, j;
    double discr_per;
    int k, pop;
    if (type == "-j")
    {
        discr_per = 5 * pow(10, -9) * pow(10, 9);   // период дискретизации (5)
        k = 30;
    }
    else if (type == "-w")
    {
        discr_per = 5 * pow(10, -9) * pow(10, 8);   // период дискретизации (5)
        k = 7000;
    }
    else 
    {
        discr_per = 5 * pow(10, -9) * pow(10, 8);   // период дискретизации (5)
        k = 30;
    }

    cout << count << endl;
    cout << "Numbers:" << endl;
    for (i = 0; i < count; i++)
    {
        num.push_back(numbers[i] * k);
    }
    for (i = 10; i < 20; i++)
    {
        //cout << i << "\t" << num[i] << "\t" << numbers[i] << endl;
    }




    // **************************************************************************************************** //
    //                                  ВЫВОД ГРАФИКА НА КОНСОЛЬ                                            //
    // **************************************************************************************************** //


//получим дескриптор консольного окна
    HWND hwnd = GetConcolWindow();

    //если дескриптор существует
    if (hwnd != NULL)
    {
        //получим контекст устройства для консольного окна
        hdc = GetWindowDC(hwnd);

        //если контекст существует - можем работать
        if (hdc != 0)
        {
            int colR = 255;
            int colG = 0;
            int colB = 0;
            double x0 = 400;
            double y0 = 430;
            int rad = 5;

            POINT coordX[2];
            POINT coordY[2];
            coordX[0].x = x0;
            coordX[0].y = y0;
            coordX[1].x = x0 + 1200;
            coordX[1].y = y0;

            coordY[0].x = x0;
            coordY[0].y = y0 + 300;
            coordY[1].x = x0;
            coordY[1].y = y0 - 400;

            Polyline(hdc, coordX, 2);
            Polyline(hdc, coordY, 2);

            HPEN Pen = CreatePen(PS_SOLID, 3, RGB(colR, colG, colB));
            SelectObject(hdc, Pen);
            HBRUSH hBrush = CreateSolidBrush(RGB(colR, colG, colB));
            SelectObject(hdc, hBrush);


            POINT poly[2];
            for (int i = 0; i < count - 1; i++)
            {
                poly[0].x = x0 + discr_per * i;
                poly[0].y = y0 - (num[i]);

                poly[1].x = x0 + discr_per * (i + 1);
                poly[1].y = y0 - (num[i + 1]);

                Polyline(hdc, poly, 2);
            }

            ////cout << "OK_1" << endl;
            //for (i = 0; i < 15; i++)
            //{
            //    cout << endl;
            //}

            discr_per = 5 * pow(10,-1);      // период дискретизации (5)
            double d_per = 5 * pow(10, 0);   // период дискретизации (5)
            if (type == "-w")
            {
                d_per = 5 * pow(10, -1);
                discr_per = 5 * pow(10, -4);     // период дискретизации (5)
            }
            else if (type == "-o")
            {
                d_per = 5 * pow(10, -1);
                discr_per = 5 * pow(10, -2);     // период дискретизации (5)
            }



            // **************************************************************************************************** //
            //                                      ВЫЧИСЛЕНИЕ ПАРАМЕТРОВ                                           //
            // **************************************************************************************************** //


            int Ua = 0;                 // индекс амплитуды сигнала
            double Ua_num;              // амплитуда сигнала
            int U_a = 0;                // индекс мин амплитуды сигнала
            int max_ind = 0;            // индекс максимальной амплитуды
            int max_Ua = 0;             // значение макс ампл
            int beg_front = 0;          // начало фронта
            int beg_top = 0;            // начало плоской вершины
            int end_top = 0;            // конец плоской вершины
            int beg_cut = 0;            // начало среза
            int end_cut = 0;            // начало среза
            int beg_per = 0;            // начало периода
            int min_ind = 0;            // индекс мин ампл
            int beg_field = 0;          // начало стабильности значений после мин ампл
            double min_Ua = 0;          // значение мин ампл
            int max_num_back = 0;       // макс ампл в следуещем периоде
            int period;                 // индекс периода
            int Un = 0;                 // ампл помехи
            int U_n = 0;
            bool blowout = false;


            // начало фронта
            // макс амплитуда
            // начало плоской вершины
            // период
            // минимальная амплитуда
            // начало среза
            // начало плоской вершины
            // конец вершины
            // поле
            // проверка на наличие выброса
            // амплитуда помехи

            int mas = count / 100;              // масштаб вычислений
            if (type == "-w")
            {
                mas = mas / 2;
            }
            else if (type == "-o")
            {
                mas = mas / 2;
            }
            double ave;                         // среднее значение разниц чисел
            double sum = 0;                     // сумма разниц
            bool check;


            double max_num = pow(100, 2) * (-1);
            double min_num = 1000;

            double r_floor = tan(10 * M_PI / 180);
            //cout << "fault = " << r_floor << endl;
            double l_floor = abs(tan(170 * M_PI / 180));
            int cc;
            double ang_k;


            // кисточка, которой будут рисоваться точки
            hBrush = CreateSolidBrush(RGB(0, 0, 255));
            SelectObject(hdc, hBrush);
            Pen = CreatePen(PS_SOLID, 3, RGB(0, 0, 255));
            SelectObject(hdc, Pen);


            // нахождение начала фронта
            check = false;
            i = 0;
            do
            { 
                ang_k = (abs((numbers[i]) - (numbers[i + mas]))) / (discr_per * mas);
                if (ang_k > r_floor)
                {
                    check = true;
                }
                else
                    i++;
            } while (!check);
            beg_front = i;
            Ellipse(hdc, x0 + d_per * beg_front - rad, y0 - num[beg_front] - rad, x0 + d_per * beg_front + rad, y0 - num[beg_front] + rad);
            //cout << "beg of front\n" << beg_front << "\t" << numbers[beg_front] << "\t" << numbers[beg_front + 1] << endl;




            i = beg_front + 1;
            //// нахождение минимальной амплитуды
            for (i = beg_front + 1; i < count - 1; i++)
            {
                if (num[i] < min_num)
                {
                    min_ind = i;
                    min_num = num[i];
                }
            }
            i++;
            min_num = pow(10, 6);




            i = beg_front + 1;;
            // нахождение максимальной амплитуды
            for (i = beg_front + 1; i < min_ind - 1; i++)
            {
                if (num[i] > max_num)
                {
                    max_ind = i;
                    max_num = num[i];
                }
            }

            
            
            
            
            // проверка на наличие выброса
            // если нет выброса
            if  (abs(abs(numbers[max_ind]) - abs(numbers[max_ind + mas])) / (discr_per * mas) < l_floor)
            {
                Ua = max_ind;
                Ua_num = numbers[max_ind];
                max_ind = 0;
            }
            // если был выброс
            if (Ua == 0)
            {
                blowout = true;
                cout << "there is a max outlier" << endl;
                Ellipse(hdc, x0 + d_per * max_ind - rad, y0 - num[max_ind] + rad, x0 + d_per * max_ind + rad, y0 - num[max_ind] - rad);
                //cout << "max index\n" << max_ind << "\t" << numbers[max_ind] << endl;
            }


//            //// поиск ещё одного большого значения
//            for (i = beg_top + 1; i < count - 1; i++)
//            {
//                if (num[i] > max_num)
//                {
//                    max_num = num[i];
//                    max_num_back = i;
//                }
//            }
//            if (abs(abs(num[max_ind]) - abs(num[max_num_back])) < 0.1)
//            {
//                cout << "max num_back index\n" << max_num_back << "\t" << num[max_num_back] << endl;
//                Ellipse(hdc, x0 + d_per * max_num_back - rad, y0 - num[max_num_back] - rad, x0 + d_per * max_num_back + rad, y0 - num[max_num_back] + rad);
//                period = max_num_back - max_ind;
//                cout << "period:\n" << period << "\t" << num[period - 1] << "   " << num[period] << "   " << num[period + 1] << endl;
//                Ellipse(hdc, x0 + d_per * period - rad, y0 - num[period] - rad, x0 + d_per * period + rad, y0 - num[period] + rad);
//            }
//            else
//            {
//                //cout << "there is no period" << endl;
//                period = count - 1;
//            }
//

            // проверка на наличие отрицательного выброса 
            // если мин значение - не выброс
            if ((abs(numbers[min_ind] - numbers[min_ind - mas]) / (discr_per*mas)) < l_floor)
            {
                if ((abs((numbers[min_ind]) - (numbers[min_ind + mas])) / (discr_per * mas)) < r_floor)
                {
                    U_a = min_ind;
                    min_ind = count - 1;
                }
            }
            // если был выброс
            if (U_a == 0)
            {
                blowout = true;
                cout << "there is a min outlier" << endl;
                //cout << "min index\n" << min_ind << "\t" << numbers[min_ind] << endl;
                Ellipse(hdc, x0 + d_per * min_ind - rad, y0 - num[min_ind] + rad, x0 + d_per * min_ind + rad, y0 - num[min_ind] - rad);
            }



            // если нет отрицательного выброса
            if (!blowout)
            {
                check = false;
                i = U_a - 1;
                do
                {
                    ang_k = (abs(numbers[i] - numbers[i - mas])) / (discr_per * mas);
                    if (ang_k > l_floor)
                    {
                        check = true;
                    }
                    else
                        i--;
                } while (!check);
                end_cut = i;
                Ellipse(hdc, x0 + d_per * end_cut - rad, y0 - num[end_cut] - rad, x0 + d_per * end_cut + rad, y0 - num[end_cut] + rad);
                //cout << "end of cut\n" << end_cut << "\t" << numbers[end_cut] << endl;
                min_ind = end_cut;
            }



            // нахождение начала среза
            check = false;
            i = min_ind - 1;
            do
            {
                ang_k = (abs((numbers[i]) - (numbers[i - mas]))) / (discr_per * mas);
                if (ang_k < l_floor)
                {
                    check = true;
                }
                else
                    i--;
            } while (!check);
            beg_cut = i+1;
            Ellipse(hdc, x0 + d_per * beg_cut - rad, y0 - num[beg_cut] - rad, x0 + d_per * beg_cut + rad, y0 - num[beg_cut] + rad);
            //cout << "beg of cut\n" << beg_cut << "\t" << numbers[beg_cut] << endl;


            // если есть выброс, то амплитуда будет смотреться по началу среза
            if (blowout)
            {
                Ua_num = numbers[beg_cut];
            }



            // если нет максимального выброса
            // нахождение начала плоской вершины
            if (!blowout)
            {
                check = false;
                i = Ua - 1;
                do
                {
                    ang_k = (abs(numbers[i] - numbers[i - mas])) / (discr_per * mas);
                    if (ang_k > l_floor)
                    {
                        check = true;
                    }
                    else
                        i--;
                } while (!check);
                beg_top = i;
                Ellipse(hdc, x0 + d_per * beg_top - rad, y0 - num[beg_top] - rad, x0 + d_per * beg_top + rad, y0 - num[beg_top] + rad);
                //cout << "beg_top\n" << beg_top << "\t" << numbers[beg_top] << endl;
            }


            if (blowout)
            {
                //  нахождение начала плоской вершины
                check = false;
                i = beg_cut - mas;
                do
                {
                    ang_k = (abs((numbers[i]) - (numbers[i - mas]))) / (discr_per * mas);
                    if (ang_k > r_floor)
                    {
                        check = true;
                    }
                    else
                        i--;
                } while (!check);
                beg_top = i;
                Ellipse(hdc, x0 + d_per * beg_top - rad, y0 - num[beg_top] - rad, x0 + d_per * beg_top + rad, y0 - num[beg_top] + rad);
            }


            //  нахождение конца плоской вершины
            check = false;
            i = beg_cut - 1;
            do
            {
                ang_k = (abs((numbers[i]) - (numbers[i + mas]))) / (discr_per * mas);
                if (ang_k < r_floor)
                {
                    check = true;
                }
                else
                    i--;
            } while (!check);
            end_top = i+mas;
            Ellipse(hdc, x0 + d_per * end_top - rad, y0 - num[end_top] - rad, x0 + d_per * end_top + rad, y0 - num[end_top] + rad);
            //cout << "end of top\n" << end_top << "\t" << numbers[end_top] << "\t" << numbers[end_top + 1] << endl;

            ave = 0;
            for (i = 0; i < beg_front; i++)
            {
                ave = ave + abs(numbers[i]);
            }
            ave = ave / beg_front;
            cout << "!!!!  " << ave << endl;
            // нахождение поля
            if (blowout)
            {
                check = false;
                cc = 0;
                i = min_ind + 1;
                do
                {
                    for (j = 0; j < mas; j++)
                    {
                        //ang_k = (abs((numbers[i]) - (numbers[i + j + 1]))) / (discr_per * (j + 1));

                        if (abs(numbers[i+j]) < ave)
                        {
                            cc++;
                            //cout << ang_k << "\n";
                        }
                    }
                    // как только начнётся подъём
                    if (cc == mas)
                    {
                        check = true;
                    }
                    else
                        i++;
                    cc = 0;
                } while (!check);
                beg_field = i;
                Ellipse(hdc, x0 + d_per * beg_field - rad, y0 - num[beg_field] - rad, x0 + d_per * beg_field + rad, y0 - num[beg_field] + rad);
            }



            //// выводы
            cout << "beg of front\n" << beg_front << "\t" << numbers[beg_front] << "\t" << numbers[beg_front + 1] << endl;
            //cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            cout << "max index\n" << max_ind << "\t" << numbers[max_ind] << endl;
            cout << "beg of top\n" << beg_top << "\t" << numbers[beg_top] << "\t" << numbers[beg_top - 1] << endl;
            //cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            cout << "end of top\n" << end_top << "\t" << numbers[end_top] << "\t" << numbers[end_top + 1] << endl;
            //cout << i << "\t" << num[i] << "\t" << num[i + 1] << "\t" << ang_k << endl;
            cout << "beg of cut\n" << beg_cut << "\t" << numbers[beg_cut] << endl;
            //cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            cout << "min index\n" << min_ind << "\t" << numbers[min_ind] << endl;
            cout << "beg_field\n" << beg_field << "\t" << numbers[beg_field] << "\t" << numbers[beg_field + 1] << endl;
            //cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;





            // **************************************************************************************************** //
            //                                           ВЫВОД ПАРАМЕТРОВ                                           //
            // **************************************************************************************************** //



            double part_01 = Ua_num * 0.1;
            double part_09 = Ua_num * 0.9;
            double part_05 = Ua_num * 0.5;
            double AUn;
            double AU_n;
            double time_front = 0;      // время фронта
            double time_work = 0;       // время работы сигнала
            double time_cut = 0;        // время среза
            double time_fr_out = 0;     // время фронта
            double time_cut_out = 0;    // время работы сигнала
            int r = 0;
            int t_f_c = 0;
            int t_c_c = 0;
            int t_w_c = 0;

            AUn = (Ua_num - num[Un]) / k;
            AU_n = num[U_n] ;


            while (numbers[r] < part_01)
            {
                r++;
            }
            while ((numbers[r] >= part_01) && (numbers[r] <= part_09) && (r < count - 1))
            {
                time_front = time_front + discr_per;
                t_f_c++;
                r++;
            }
            cout << "time of front\n" << r << "\t" << t_f_c << "\t" << time_front << endl;


            r = end_top;
            while (numbers[r] > part_09)
            {
                r++;
            }
            while ((numbers[r] >= part_01) && (numbers[r] <= part_09) && (r < count - 1))
            {
                time_cut = time_cut + discr_per;
                t_c_c++;
                r++;
            }
            cout << "time of cut\n" << r << "\t" << t_c_c << "\t" << time_cut << endl;


            r = beg_front;
            while (numbers[r] < part_05)
            {
                r++;
            }
            while ((numbers[r] >= part_05) && (r < count - 1))
            {
                time_work = time_work + discr_per;
                t_w_c++;
                r++;
            }
            cout << "time of work\n" << r << "\t" << t_w_c << "\t" << time_work << endl;


            r = beg_cut;
            while (numbers[r] > part_01)
            {
                r++;
            }
            while ((r < beg_field) && (r < count - 1))
            {
                time_cut_out = time_cut_out + discr_per;
                r++;
            }
            cout << "time_cut_out\n" << r << "\t" << time_cut_out << endl;


            r = beg_front;
            while (numbers[r] < part_09)
            {
                r++;
            }
            while ((r < beg_top) && (r < count - 1))
            {
                time_fr_out = time_fr_out + discr_per;
                r++;
            }
            cout << "time_fr_out\n" << r << "\t" << time_fr_out << endl;


            if (blowout)
            {
                // аплитуды выброса
                double U_n_min = numbers[max_ind];
                for (i = max_ind + 1; i < beg_top; i++)
                {
                    if (numbers[i] < U_n_min)
                    {
                        U_n_min = numbers[i];
                        U_n = i;
                    }
                }

                double Un_max = numbers[min_ind];
                for (i = min_ind + 1; i < beg_field; i++)
                {
                    if (numbers[i] > Un_max)
                    {
                        Un_max = numbers[i];
                        Un = i;
                    }
                }
                cout << "Un = " << numbers[Un] << "\t" << "U_n = " << numbers[U_n] << endl;
                cout << "Un = " << Un << "\t" << "U_n = " << U_n << endl;
            }
            else 
            {
                cout << "there is no blowout\n";
                cout << "Un = " << Un << "\t" << "U_n = " << U_n << endl;;
            }


            double Ub01 = (numbers[max_ind] - Ua_num);
            double Ub10 = numbers[min_ind];
            cout << "Ub01 = " << Ub01 << "\tUb10 = " << Ub10 << endl;
            cout << "AUn = " << AUn << "\t" << "AU_n = " << AU_n << endl;


        }
    }//end if

    return 0;
}
