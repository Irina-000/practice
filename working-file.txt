#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <cmath>
#include <windows.h>
#include "ConWin.h"
#include <process.h>


using namespace std;
extern HDC hdc; // объявим  контекст устройства

HDC hdc;	// Объявим контекст устройства
            // Контекст устройства по сути это структура,
            // содержащая описание видеокарты на вашем компьютере
            // и всех необходимых графических элементов



// размеры окна для графика
const int kolvo = 200;
const double discr_per = 5 * pow(10, -9) * pow(10, 9);   // период дискретизации (5)
const int k = 30;

int main(int argc, const char* argv[])
{

    ifstream inputFile("C:\\Users\\User\\Desktop\\практика\\просто_тесты\\2.txt"); //чтение из файла
    // если не существует этого файла
    if (!inputFile)
    {
        //вывод об ошибке
        cerr << "Error! Not exist!" << endl;
        return 1;
    }


    string test;
    getline(inputFile, test);   //перенос всего содержимого в одну строку
    inputFile.close();          //закрытие файла

    // Удаляем скобки
    // если первым символом явдяется скобка
    if (test.front() == '[')
    {
        test.erase(0, 1);
    }
    // если последним символом явдяется скобка
    if (test.back() == ']')
    {
        test.pop_back();
    }

    vector<double> numbers;     // вектор чисел
    stringstream str(test);     // переменная для перевода строки в набор чисел
    string number;

    while (getline(str, number, ','))       // вычленение чисел из строки, разделённых запятой
    {
        // добавление нового числа в конец вектора чисел
        numbers.push_back(stod(number));
    }

    int count = numbers.size();
    int i, j;
    cout << count << endl;
    cout << "Numbers:" << endl;
    //for (i = 0; i < count; i++)
        //{
        //    cout << i << "\t" << numbers[i] << endl;
        //}
        //for (i = 0; i < 45; i++)
        //{
        //    cout << endl;
        //}


        //получим дескриптор консольного окна
        HWND hwnd = GetConcolWindow();

    //если дескриптор существует
    if (hwnd != NULL)
    {
        //получим контекст устройства для консольного окна
        hdc = GetWindowDC(hwnd);

        //если контекст существует - можем работать
        if (hdc != 0)
        {
            int colR = 255;
            int colG = 0;
            int colB = 0;
            double x0 = 400;
            double y0 = 370;
            int rad = 5;

            POINT coordX[2];
            POINT coordY[2];
            coordX[0].x = x0;
            coordX[0].y = y0;
            coordX[1].x = x0 + 1200;
            coordX[1].y = y0;

            coordY[0].x = x0;
            coordY[0].y = y0 + 300;
            coordY[1].x = x0;
            coordY[1].y = y0 - 400;

            Polyline(hdc, coordX, 2);
            Polyline(hdc, coordY, 2);

            HPEN Pen = CreatePen(PS_SOLID, 3, RGB(colR, colG, colB));
            SelectObject(hdc, Pen);
            HBRUSH hBrush = CreateSolidBrush(RGB(colR, colG, colB));
            SelectObject(hdc, hBrush);


            POINT poly[2];
            for (int i = 0; i < count - 1; i++)
            {
                poly[0].x = x0 + discr_per * i;
                poly[0].y = y0 - (numbers[i] * k);

                poly[1].x = x0 + discr_per * (i + 1);
                poly[1].y = y0 - (numbers[i + 1] * k);

                Polyline(hdc, poly, 2);
            }



            int Ua = 0;                 // индекс амплитуды сигнала
            double Ua_num;              // амплитуда сигнала
            int max_ind = 0;
            int max_Ua = 0;
            int beg_front = 0;
            int beg_top = 0;
            int end_top = 0;
            int beg_cut = 0;
            int end_cut = 0;
            int beg_per = 0;
            int min_ind = 0;
            int beg_field = 0;
            double min_Ua = 0;
            double time_front = 0;
            double time_work = 0;
            double time_cut = 0;
            int max_num_back = 0;
            int period;

            // начало фронта
            // макс амплитуда
            // проверка на наличие выброса
            // начало плоской вершины
            // конец вершины
            // начало среза
            // минимальная амплитуда
            // конец среза

            double pog = 0.1;               // допустимая разница
            double max_num = pow(1, -6);
            double min_num = 1000;
            double dif = 1000;

            //// поиск периода
            //for (i = 3; i < count - 3; i++)
            //{
            //    if ((numbers[0] == numbers[i]) &&
            //        (numbers[1] == numbers[i + 1]) &&
            //        (numbers[2] == numbers[i + 2]))
            //    {
            //        beg_per = i;
            //    }       
            //}
            //cout << "beg of period\n" << beg_per << "\t" << numbers[beg_per] << endl;

            hdc = GetWindowDC(hwnd);
            hBrush = CreateSolidBrush(RGB(0, 0, 255));
            SelectObject(hdc, hBrush);
            // нахождение начала фронта
            i = 0;
            while ((abs(abs(numbers[i]) - abs(numbers[i + 1])) < pog) && (i < count - 1))
            {
                //cout << abs(abs(numbers[i]) - abs(numbers[i+1])) << endl;
                i++;
            }
            beg_front = i;
            cout << "beg of front\n" << beg_front << "\t" << numbers[beg_front] << "\t" << numbers[beg_front + 1] << endl;
            i++;
            Ellipse(hdc, x0 + discr_per * beg_front - rad, y0 - numbers[beg_front] * k - rad, x0 + discr_per * beg_front + rad, y0 - numbers[beg_front] * k + rad);


            // нахождение максимальной амплитуды
            while ((numbers[i + 1] > numbers[i]) && (i < count - 1))
            {
                i++;
            }
            max_ind = i;
            cout << "max index\n" << max_ind << "\t" << numbers[max_ind] << endl;
            i++;
            Ellipse(hdc, x0 + discr_per * max_ind - rad, y0 - numbers[max_ind] * k + rad, x0 + discr_per * max_ind + rad, y0 - numbers[max_ind] * k - rad);


            // проверка на наличие выброса
            if (((numbers[max_ind] - numbers[max_ind + 1]) < pog) &&
                ((numbers[max_ind + 1] - numbers[max_ind + 2]) < pog) &&
                ((numbers[max_ind + 2] - numbers[max_ind + 3]) < pog))
            {
                // если последующие значения справа от макс отличаются незначительно
                // то макс значение - просто амплитуда
                Ua = max_ind;
            }
            else
            {
                // иначе - макс значение - это выброс
                max_Ua = max_ind;
            }
            // у нас теперь есть либо амплитуда, либо выброс

            // если был выброс
            if (Ua == 0)
            {
                Ua_num = numbers[beg_cut];
                cout << "there is an outlier" << endl;
            }
            else
            {
                Ua_num = numbers[Ua];
            }


            // если был выброс, то теперь нужно найти амплитуду
            // для этого найдем начало среза
            i = max_ind;
            while ((abs(abs(numbers[i]) - abs(numbers[i + 1])) > pog) ||
                (abs(abs(numbers[i + 1]) - abs(numbers[i + 2])) > pog) ||
                (abs(abs(numbers[i + 2]) - abs(numbers[i + 3])) > pog))
            {
                i++;
            }
            // начало плоcкой вершины
            beg_top = i;
            cout << "beg of top\n" << beg_top << "\t" << numbers[beg_top] << endl;
            Ellipse(hdc, x0 + discr_per * beg_top - rad, y0 - numbers[beg_top] * k - rad, x0 + discr_per * beg_top + rad, y0 - numbers[beg_top] * k + rad);
            i = 0;



            // поиск ещё одного большого значения
            for (i = beg_top + 1; i < count - 1; i++)
            {
                if (numbers[i] > max_num)
                {
                    max_num = numbers[i];
                    max_num_back = i;
                }
            }
            if (abs(max_num_back - max_num) < pog)
            {
                cout << "max num_back index\n" << max_num_back << "\t" << numbers[max_num_back] << endl;
                Ellipse(hdc, x0 + discr_per * max_num_back - rad, y0 - numbers[max_num_back] * k - rad, x0 + discr_per * max_num_back + rad, y0 - numbers[max_num_back] * k + rad);
                period = max_num_back - max_ind;
                cout << "period:\n" << period << "\t" << numbers[period - 1] << "   " << numbers[period] << "   " << numbers[period + 1] << endl;
                Ellipse(hdc, x0 + discr_per * period - rad, y0 - numbers[period] * k - rad, x0 + discr_per * period + rad, y0 - numbers[period] * k + rad);
            }
            else
            {
                cout << "there is no period" << endl;
                period = count - 1;
            }


            i = beg_top;
            while ((abs(abs(numbers[i]) - abs(numbers[i + 1])) < pog) && (i < count - 1))
            {
                i++;
            }
            // конец плоской вершины => следующее значение - начало среза
            end_top = i;
            cout << "end of top\n" << end_top << "\t" << numbers[end_top] << endl;
            i++;
            Ellipse(hdc, x0 + discr_per * end_top - rad, y0 - numbers[end_top] * k - rad, x0 + discr_per * end_top + rad, y0 - numbers[end_top] * k + rad);

            beg_cut = i;
            cout << "beg of cut\n" << beg_cut << "\t" << numbers[beg_cut] << endl;
            Ellipse(hdc, x0 + discr_per * beg_cut - rad, y0 - numbers[beg_cut] * k - rad, x0 + discr_per * beg_cut + rad, y0 - numbers[beg_cut] * k + rad);


            // нахождение минимальной амплитуды
            for (i = beg_cut; i < period; i++)
            {
                if (numbers[i] < min_num)
                {
                    min_ind = i;
                    min_num = numbers[i];
                }
            }
            cout << "min index\n" << min_ind << "\t" << numbers[min_ind] << endl;
            i++;
            Ellipse(hdc, x0 + discr_per * min_ind - rad, y0 - numbers[min_ind] * k + rad, x0 + discr_per * min_ind + rad, y0 - numbers[min_ind] * k - rad);

            i = beg_cut;
            while (abs(numbers[i]) > 0.1)
            {
                i++;
            }
            end_cut = i;
            cout << "end_cut\n" << end_cut << "\t" << numbers[end_cut] << endl;
            i++;
            Ellipse(hdc, x0 + discr_per * end_cut - rad, y0 - numbers[end_cut] * k + rad, x0 + discr_per * end_cut + rad, y0 - numbers[end_cut] * k - rad);

            i = min_ind;
            while ((abs(abs(numbers[i]) - abs(numbers[i + 1])) > pog) ||
                (abs(abs(numbers[i + 1]) - abs(numbers[i + 2])) > pog) ||
                (abs(abs(numbers[i + 2]) - abs(numbers[i + 3])) > pog))
            {
                i++;
            }
            // начало плоcкой вершины
            beg_field = i;
            cout << "beg of field\n" << beg_field << "\t" << numbers[beg_field] << endl;
            Ellipse(hdc, x0 + discr_per * beg_field - rad, y0 - numbers[beg_field] * k - rad, x0 + discr_per * beg_field + rad, y0 - numbers[beg_field] * k + rad);
            i = 0;


            ////i = 0;
            ////while ((abs(abs(numbers[i]) - abs(numbers[i])) < pog) && (i < count - 1))
            ////{
            ////    i++;
            ////}
            ////beg_front = i;
            ////cout << "beg of front\n" << beg_front << "\t" << numbers[beg_front] << endl;
            ////i++;

            //double part_01 = Ua_num * 0.1;
            //double part_09 = Ua_num * 0.9;
            //int r = 0;
            //int t_f_c = 0;
            //while (numbers[r] < part_01)
            //{
            //    r++;
            //}
            //while ((numbers[r] >= part_01) && (numbers[r] <= part_09) && (r < count - 1))
            //{
            //    time_front = time_front + discr_per;
            //    t_f_c++;
            //    r++;
            //}
            //cout << "time of front\n" << r << "\t" << t_f_c << "\t" << time_front << endl;

        }
    }//end if





    return 0;
}
