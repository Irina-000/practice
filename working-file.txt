#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <cmath>
#include <windows.h>
#include "ConWin.h"
#include <process.h>
#define _USE_MATH_DEFINES 
#define M_PI 3.14159265358979323846


using namespace std;
extern HDC hdc; // объявим  контекст устройства

HDC hdc;	// Объявим контекст устройства
            // Контекст устройства по сути это структура,
            // содержащая описание видеокарты на вашем компьютере
            // и всех необходимых графических элементов



// размеры окна для графика
const int kolvo = 200;
const double discr_per = 5 * pow(10, -9) * pow(10, 9);   // период дискретизации (5)
const int k = 30;

int main(int argc, const char* argv[])
{

    // **************************************************************************************************** //
    //                                          ЧТЕНИЕ ФАЙЛА                                                //
    // **************************************************************************************************** //


    ifstream inputFile("C:\\Users\\User\\Desktop\\практика\\просто_тесты\\3.txt"); //чтение из файла
    //ifstream inputFile("C:\\Users\\User\\Desktop\\практика\\импульсы_с_выбросами\\1.txt"); //чтение из файла
    // если не существует этого файла
    if (!inputFile)
    {
        //вывод об ошибке
        cerr << "Error! Not exist!" << endl;
        return 1;
    }


    string test;
    getline(inputFile, test);                   //перенос всего содержимого в одну строку
    inputFile.close();                          //закрытие файла

    // Удаляем скобки
    // если первым символом явдяется скобка
    if (test.front() == '[')
    {
        test.erase(0, 1);
    }
    // если последним символом явдяется скобка
    if (test.back() == ']')
    {
        test.pop_back();
    }

    vector<double> num;                         // вектор истинных чисел
    vector<double> numbers;                     // вектор удобных чисел
    stringstream str(test);                     // переменная для перевода строки в набор чисел
    string number;

    while (getline(str, number, ','))           // вычленение чисел из строки, разделённых запятой
    {
        // добавление нового числа в конец вектора чисел
        num.push_back(stod(number));
    }

    int count = num.size();
    int i, j;
    cout << count << endl;
    cout << "Numbers:" << endl;
    for (i = 0; i < count; i++)
    {
        numbers.push_back(num[i]*k);
    }
    for (i = 10; i < 20; i++)
    {
        //cout << i << "\t" << num[i] << endl;
    }





            // **************************************************************************************************** //
            //                                  ВЫВОД ГРАФИКА НА КОНСОЛЬ                                            //
            // **************************************************************************************************** //


    //получим дескриптор консольного окна
    HWND hwnd = GetConcolWindow();

    //если дескриптор существует
    if (hwnd != NULL)
    {
        //получим контекст устройства для консольного окна
        hdc = GetWindowDC(hwnd);

        //если контекст существует - можем работать
        if (hdc != 0)
        {
            int colR = 255;
            int colG = 0;
            int colB = 0;
            double x0 = 350;
            double y0 = 370;
            int rad = 5;

            POINT coordX[2];
            POINT coordY[2];
            coordX[0].x = x0;
            coordX[0].y = y0;
            coordX[1].x = x0 + 1200;
            coordX[1].y = y0;

            coordY[0].x = x0;
            coordY[0].y = y0 + 300;
            coordY[1].x = x0;
            coordY[1].y = y0 - 400;

            Polyline(hdc, coordX, 2);
            Polyline(hdc, coordY, 2);

            HPEN Pen = CreatePen(PS_SOLID, 3, RGB(colR, colG, colB));
            SelectObject(hdc, Pen);
            HBRUSH hBrush = CreateSolidBrush(RGB(colR, colG, colB));
            SelectObject(hdc, hBrush);


            POINT poly[2];
            for (int i = 0; i < count - 1; i++)
            {
                poly[0].x = x0 + discr_per * i;
                poly[0].y = y0 - (numbers[i]);

                poly[1].x = x0 + discr_per * (i + 1);
                poly[1].y = y0 - (numbers[i + 1]);

                Polyline(hdc, poly, 2);
            }

            //cout << "OK_1" << endl;
            //for (i = 0; i < 15; i++)
            //{
            //    cout << endl;
            //}





            // **************************************************************************************************** //
            //                                      ВЫЧИСЛЕНИЕ ПАРАМЕТРОВ                                           //
            // **************************************************************************************************** //


            int Ua = 0;                 // индекс амплитуды сигнала
            double Ua_num;              // амплитуда сигнала
            int U_a = 0;                // индекс мин амплитуды сигнала
            int max_ind = 0;            // индекс максимальной амплитуды
            int max_Ua = 0;             // значение макс ампл
            int beg_front = 0;          // начало фронта
            int beg_top = 0;            // начало плоской вершины
            int end_top = 0;            // конец плоской вершины
            int beg_cut = 0;            // начало среза
            //int end_cut = 0;          // конец среза
            int beg_per = 0;            // начало периода
            int min_ind = 0;            // индекс мин ампл
            int beg_field = 0;          // начало стабильности значений после мин ампл
            double min_Ua = 0;          // значение мин ампл
            int max_num_back = 0;       // макс ампл в следуещем периоде
            int period;                 // индекс периода
            int Un = 0;                 // ампл помехи
            int U_n = 0;


            // начало фронта
            // макс амплитуда
            // начало плоской вершины
            // период
            // минимальная амплитуда
            // начало среза
            // начало плоской вершины
            // конец вершины
            // поле
            // проверка на наличие выброса
            // амплитуда помехи

            int mas = count/100;                // масштаб вычислений
            double ave;                         // среднее значение разниц чисел
            double sum = 0;                     // сумма разниц
            bool check;

            //// нахождение средней разницы между соседними значениями
            //for (int h = 0; h < count - 1; h ++ )
            //{
            //    sum = sum + abs(abs(numbers[h]) - abs(numbers[h + 1]));
            //}
            //ave = sum / (count - 1);
            //double front = ave;                 // резкий скачок в изменении значений

            double max_num = pow(1, -6);
            double min_num = 1000;

            double r_floor = tan(10*M_PI/180);
            cout << "fault = " << r_floor << endl;
            double l_floor = abs(tan(170 * M_PI / 180));
            int cc;
            double ang_k;


            // кисточка, которой будут рисоваться точки
            hBrush = CreateSolidBrush(RGB(0, 0, 255));
            SelectObject(hdc, hBrush);
            Pen = CreatePen(PS_SOLID, 3, RGB(0, 0, 255));
            SelectObject(hdc, Pen);


            // нахождение начала фронта
            check = false;
            cc = 0;
            i = 0;
            do
            {
                ang_k = (abs(abs(num[i]) - abs(num[i + mas]))) / (discr_per*mas);
                if (ang_k > r_floor)
                {
                    check = true;
                }
                else
                    i++;
            } while (!check);
            beg_front = i;
            cout << "beg of front\n" << beg_front << "\t" << numbers[beg_front] << "\t" << numbers[beg_front + 1] << endl;
            //cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            Ellipse(hdc, x0 + discr_per * beg_front - rad, y0 - numbers[beg_front] - rad, x0 + discr_per * beg_front + rad, y0 - numbers[beg_front] + rad);




            i++;
            // нахождение максимальной амплитуды
            while ((numbers[i + 1] > numbers[i]) && (i < count - 1))
            {
                i++;
            }
            max_ind = i;
            cout << "max index\n" << max_ind << "\t" << numbers[max_ind] << endl;
            Ellipse(hdc, x0 + discr_per * max_ind - rad, y0 - numbers[max_ind] + rad, x0 + discr_per * max_ind + rad, y0 - numbers[max_ind] - rad);




            // пробное нахождение начала вершины
            check = false;
            cc = 0;
            i = max_ind + 1;
            do
            {
                ang_k = (abs(abs(numbers[i]) - abs(numbers[i + mas]))) / (discr_per * mas);
                if (ang_k < r_floor)
                {
                    check = true;
                }
                else
                    i++;
            } while (!check);
            beg_top = i;
            cout << "beg of top\n" << beg_top << "\t" << numbers[beg_top] << "\t" << numbers[beg_top + 1] << endl;
            //cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            Ellipse(hdc, x0 + discr_per * beg_top - rad, y0 - numbers[beg_top] - rad, x0 + discr_per * beg_top + rad, y0 - numbers[beg_top] + rad);



            //// поиск ещё одного большого значения
            for (i = beg_top+1; i < count-1; i++)
            {
                if (numbers[i] > max_num)
                {
                    max_num = numbers[i];
                    max_num_back = i;
                }
            }
            //out << "!!!!!  " << numbers[max_ind] << "\t" << numbers[max_num_back] << " !!!!!!" << endl;
            if (abs(abs(numbers[max_ind]) - abs(numbers[max_num_back])) < 0.1)
            {
                cout << "max num_back index\n" << max_num_back << "\t" << numbers[max_num_back] << endl;
                Ellipse(hdc, x0 + discr_per * max_num_back - rad, y0 - numbers[max_num_back] - rad, x0 + discr_per * max_num_back + rad, y0 - numbers[max_num_back]  + rad);
                period = max_num_back - max_ind;
                cout << "period:\n" << period << "\t" << numbers[period - 1] << "   " << numbers[period] << "   " << numbers[period + 1] << endl;
                Ellipse(hdc, x0 + discr_per * period - rad, y0 - numbers[period] - rad, x0 + discr_per * period + rad, y0 - numbers[period] + rad);
            }
            else
            {
                cout << "there is no period" << endl;
                period = count - 1;
            }




            i = beg_top + 1;
            //// нахождение минимальной амплитуды
            for (i = beg_top + 1; i < period; i++)
            {
                if (numbers[i] < min_num)
                {
                    min_ind = i;
                    min_num = numbers[i];
                }
            }
            cout << "min index\n" << min_ind << "\t" << numbers[min_ind] << endl;
            i++;
            Ellipse(hdc, x0 + discr_per * min_ind - rad, y0 - numbers[min_ind] + rad, x0 + discr_per * min_ind + rad, y0 - numbers[min_ind] - rad);
            


            // проверка на наличие отрицательного выброса 
            // если мин значение - выброс
            if (abs(abs(numbers[min_ind]) - abs(numbers[min_ind - 1])) / discr_per > l_floor &&
                abs(abs(numbers[min_ind]) - abs(numbers[min_ind + mas])) / discr_per > r_floor)
            {
                // запоминаем его как мин амплитуда
                U_a = min_ind;
            }
            else
            {
                // иначе считаем, что мин А нет
                min_ind = count - 1;
            }
            // если не было выброс
            if (U_a == 0)
            {
                cout << "there is an min outlier" << endl;
            }


            // нахождение начала среза
            check = false;
            cc = 0;
            i = min_ind - 1;
            do
            {
                ang_k = (abs(abs(numbers[i]) - abs(numbers[i - mas]))) / (discr_per * mas);
                if (ang_k < l_floor)
                {
                    check = true;
                }
                else
                    i--;
            } while (!check);
            beg_cut = i;
            cout << "beg of cut\n" << beg_cut << "\t" << numbers[beg_cut] << endl;
            //cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            Ellipse(hdc, x0 + discr_per * beg_cut - rad, y0 - numbers[beg_cut]  - rad, x0 + discr_per * beg_cut + rad, y0 - numbers[beg_cut]  + rad);



            //  нахождение начала плоской вершины
            check = false;
            cc = 0;
            i = beg_cut - 2;
            do
            {
                ang_k = (abs(abs(numbers[i]) - abs(numbers[i - mas]))) / (discr_per * mas);
                if (ang_k > r_floor)
                {
                    check = true;
                }
                else
                    i--;
            } while (!check);
            beg_top = i;
            cout << "beg of top\n" << beg_top << "\t" << numbers[beg_top] << "\t" << numbers[beg_top + 1] << endl;
            //cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            Ellipse(hdc, x0 + discr_per * beg_top - rad, y0 - numbers[beg_top] - rad, x0 + discr_per * beg_top + rad, y0 - numbers[beg_top] + rad);



            //  нахождение конца плоской вершины
            check = false;
            cc = 0;
            i = beg_cut - 2;
            do
            {
                ang_k = (abs(abs(numbers[i]) - abs(numbers[i + mas]))) / (discr_per * mas);
                if (ang_k < l_floor)
                {
                    check = true;
                }
                else
                    i--;
            } while (!check);
            end_top = i;
            cout << "end of top\n" << end_top << "\t" << numbers[end_top] << "\t" << numbers[end_top+1] << endl;
            cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            Ellipse(hdc, x0 + discr_per * end_top - rad, y0 - numbers[end_top]  - rad, x0 + discr_per * end_top + rad, y0 - numbers[end_top]  + rad);




            // нахождение поля
            check = false;
            cc = 0;
            i = min_ind + 1;
            do
            {
                ang_k = (abs(abs(numbers[i]) - abs(numbers[i + mas]))) / (discr_per * mas);
                if (ang_k < r_floor)
                {
                    check = true;
                }
                else
                    i++;
            } while (!check);
            beg_field = i;
            cout << "beg_field\n" << beg_field << "\t" << numbers[beg_field] << "\t" << numbers[beg_field + 1] << endl;
            cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            Ellipse(hdc, x0 + discr_per * beg_field - rad, y0 - numbers[beg_field] - rad, x0 + discr_per * beg_field + rad, y0 - numbers[beg_field] + rad);



            // аплитуды выброса
            double Un_min = numbers[max_ind];
            for (i = max_ind + 1; i < beg_top; i++)
            {
                if (numbers[i] < Un_min)
                {
                    Un_min = numbers[i];
                    Un = i;
                }
            }

            double U_n_max = numbers[min_ind];
            for (i = min_ind + 1; i < beg_field; i++)
            {
                if (numbers[i] > U_n_max)
                {
                    U_n_max = numbers[i];
                    U_n = i;
                }
            }
            cout << "Un = " << Un << "\t" << "U_n = " << U_n << endl;


            // проверка на наличие выброса
            // если есть выброс
            if ((abs(abs(numbers[max_ind]) - abs(numbers[max_ind - 1])) / discr_per > r_floor) &&
                (abs(abs(numbers[max_ind]) - abs(numbers[max_ind + mas])) / (discr_per*mas) > l_floor))
            {
            }
            else
            {
                // иначе - макс значение - просто амплитуда
                Ua = max_ind;
                Ua_num = numbers[max_ind];
            }
            // если был выброс
            if (Ua == 0)
            {
                if (abs(abs(num[end_top]) - abs(num[beg_cut])) / discr_per > l_floor)
                {
                    Ua_num = numbers[end_top];
                    cout << "top" << endl;
                }
                else
                {
                    Ua_num = numbers[beg_cut];
                    cout << "cut" << endl;
                }
                cout << "there is an outlier" << endl;
            }
            else
            {
                Ua_num = numbers[Ua];
            }




            // **************************************************************************************************** //
            //                                           ВЫВОД ПАРАМЕТРОВ                                           //
            // **************************************************************************************************** //



            double part_01 = Ua_num * 0.1;
            double part_09 = Ua_num * 0.9;
            double part_05 = Ua_num * 0.5;
            double AUn;
            double AU_n;
            double time_front = 0;      // время фронта
            double time_work = 0;       // время работы сигнала
            double time_cut = 0;        // время среза
            double time_fr_out = 0;     // время фронта
            double time_cut_out = 0;    // время работы сигнала
            int r = 0;
            int t_f_c = 0;
            int t_c_c = 0;
            int t_w_c = 0;

            //POINT p_09[2];
            //p_09[0].x = x0+20;
            //p_09[0].y = y0 - part_09;
            //p_09[1].x = x0 + 800;
            //p_09[1].y = y0 - part_09;
            //Polyline(hdc, p_09, 2);

            //POINT p_01[2];
            //p_01[0].x = x0 + 20;
            //p_01[0].y = y0 - part_01;
            //p_01[1].x = x0 + 800;
            //p_01[1].y = y0 - part_01;
            //Polyline(hdc, p_01, 2);

            AUn = (Ua_num - numbers[Un]) / k;
            AU_n = numbers[U_n] / k;


            while (numbers[r] < part_01)
            {
                r++;
            }
            while ((numbers[r] >= part_01) && (numbers[r] <= part_09) && (r < count - 1))
            {
                time_front = time_front + discr_per;
                t_f_c++;
                r++;
            }
            cout << "time of front\n" << r << "\t" << t_f_c << "\t" << time_front << endl;


            r = end_top;
            while (numbers[r] > part_09)
            {
                r++;
            }
            while ((numbers[r] >= part_01) && (numbers[r] <= part_09) && (r < count - 1))
            {
                time_cut = time_cut + discr_per;
                t_c_c++;
                r++;
            }
            cout << "time of cut\n" << r << "\t" << t_c_c << "\t" << time_cut << endl;


            r = beg_front;
            while (numbers[r] < part_05)
            {
                r++;
            }
            while ((numbers[r] >= part_05) && (r < count - 1))
            {
                time_work = time_work + discr_per;
                t_w_c++;
                r++;
            }
            cout << "time of work\n" << r << "\t" << t_w_c << "\t" << time_work << endl;


            r = beg_cut;
            while (numbers[r] > part_01)
            {
                r++;
            }
            while ((r < beg_field) && (r < count - 1))
            {
                time_cut_out = time_cut_out + discr_per;
                r++;
            }
            cout << "time_cut_out\n" << r << "\t" << time_cut_out << endl;


            r = beg_front;
            while (numbers[r] < part_09)
            {
                r++;
            }
            while ((r < beg_top) && (r < count - 1))
            {
                time_fr_out = time_fr_out + discr_per;
                r++;
            }
            cout << "time_fr_out\n" << r << "\t" << time_fr_out << endl;



            double Ub01 = (numbers[max_ind] - Ua_num)/k;
            double Ub10 = numbers[min_ind]/k;
            cout << "Ub01 = " << Ub01 << "\tUb10 = " << Ub10 << endl;
            cout << "AUn = " << AUn << "\t" << "AU_n = " << AU_n << endl;





        }
    }//end if

  



    return 0;
}
