#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <cmath>
#include <windows.h>
#include "ConWin.h"
#include <process.h>
#include <conio.h>
#define _USE_MATH_DEFINES 
#define M_PI 3.14159265358979323846


using namespace std;
extern HDC hdc; // объявим  контекст устройства
void printToCoordinates(int x, int y, const std::string& text)
{
    printf("\033[%d;%dH%s\n", x, x, text.c_str());
}

void gotoxy(double x, double y) //Поместить курсор на определенные координаты
{
    COORD pos = {x,y}; // Инициализируются поля переменной Coor 
    SetConsoleCursorPosition(GetConcolWindow, pos); // Установка курсора на координаты, указанные в структурной переменной Coor
}

HDC hdc;	// Объявим контекст устройства
            // Контекст устройства по сути это структура,
            // содержащая описание видеокарты на вашем компьютере
            // и всех необходимых графических элементов



int main(int argc, const char* argv[])
{

    // **************************************************************************************************** //
    //                                          ЧТЕНИЕ ФАЙЛА                                                //
    // **************************************************************************************************** //


    string type;
    int ord;
    string ch_ord;

    // выбор типа файла
    cout << "choose type of file:\njust tests -j\n" << "without blowout -o \nwith blowout -w\n";
    cin >> type;
    while ((type != "-j") && (type != "-o") && (type != "-w"))
    {
        cout << "wrong type! try again\n";
        cin >> type;
    }


    // выбор номера файла
    cout << "enter number of file:";
    if (type == "-j")
    {
        cout << " between 1 and 20\n";
        cin >> ord;
        while ((ord <1) || (ord > 20))
        {
            cout << "wrong number! try again\n";
            cin >> ord;
        }

    }
    else if ((type == "-o") || (type == "-w"))
    {
        cout << " between 1 and 5\n";
        cin >> ord;
        while ((ord < 1) || (ord > 5))
        {
            cout << "wrong number! try again\n";
            cin >> ord;
        }

    }

    ch_ord = to_string(ord);

    string filename;
    // создание имени файла
    filename = "C:\\Users\\User\\Desktop\\практика\\";
    if (type == "-j")
    {
        filename = filename + "просто_тесты\\" + ch_ord + ".txt";
    }
    else if (type == "-w")
    {
        filename = filename + "импульсы_с_выбросами\\" + ch_ord + ".txt";
    }
    else 
    {
        filename = filename + "импульсы_без_выбросов\\" + ch_ord + ".txt";
    }
    //cout << filename << endl;



    ifstream inputFile(filename);
    // если не существует этого файла
    if (!inputFile)
    {
        //вывод об ошибке
        cerr << "Error! Not exist!" << endl;
        return 1;
    }


    string test;
    getline(inputFile, test);                   //перенос всего содержимого в одну строку
    inputFile.close();                          //закрытие файла

    // Удаляем скобки
    // если первым символом явдяется скобка
    if (test.front() == '[')
    {
        test.erase(0, 1);
    }
    // если последним символом явдяется скобка
    if (test.back() == ']')
    {
        test.pop_back();
    }

    vector<double> num;                         // вектор удобных чисел
    vector<double> numbers;                     // вектор истинных чисел
    stringstream str(test);                     // переменная для перевода строки в набор чисел
    string number;

    while (getline(str, number, ','))           // вычленение чисел из строки, разделённых запятой
    {
        // добавление нового числа в конец вектора чисел
        numbers.push_back(stod(number));
    }

    int count = numbers.size();
    int i, j;
    double discr_per;
    int k;

    // если взят файл, в котором чисел немного
    if (type == "-j")
    {
        discr_per = 5 * pow(10, -9) * pow(10, 9);   // период дискретизации (5)
        k = 30;
    }

    // если чисел много и они очень маленькие
    else if (type == "-w")
    {
        discr_per = 5 * pow(10, -9) * pow(10, 8);   // период дискретизации (5)
        k = 7000;
    }

    // если просто чисел много 
    else 
    {
        discr_per = 5 * pow(10, -9) * pow(10, 8);   // период дискретизации (5)
        k = 30;
    }


    // удобные числа для рисовани графика
    for (i = 0; i < count; i++)
    {
        num.push_back(numbers[i] * k);
    }




    // **************************************************************************************************** //
    //                                  ВЫВОД ГРАФИКА НА КОНСОЛЬ                                            //
    // **************************************************************************************************** //


//получим дескриптор консольного окна
    HWND hwnd = GetConcolWindow();

    //если дескриптор существует
    if (hwnd != NULL)
    {
        //получим контекст устройства для консольного окна
        hdc = GetWindowDC(hwnd);

        //если контекст существует - можем работать
        if (hdc != 0)
        {

            setlocale(LC_ALL, "Russian");
            // начальные координаты, с которых будет рисоваться график
            double x0 = 550;
            double y0 = 520;
            int rad = 5;        // радиус точек

            //for (int g = 0; g < 7; g++)
            //{
            //    cout << endl;
            //}


            // оси координат
            POINT coordX[2];
            POINT coordY[2];
            coordX[0].x = x0;
            coordX[0].y = y0;
            coordX[1].x = x0 + 1200;
            coordX[1].y = y0;

            x0 = x0 + 50;
            coordY[0].x = x0;
            coordY[0].y = y0 + 70;
            coordY[1].x = x0;
            coordY[1].y = y0 - 400;


            Polyline(hdc, coordX, 2);
            Polyline(hdc, coordY, 2);

            HPEN Pen = CreatePen(PS_SOLID, 3, RGB(255,0,0));
            SelectObject(hdc, Pen);
            HBRUSH hBrush = CreateSolidBrush(RGB(255, 0, 0));
            SelectObject(hdc, hBrush);


            // рисование линий, соединяющих точки
            POINT poly[2];
            for (int i = 0; i < count - 1; i++)
            {
                poly[0].x = x0 + discr_per * i;
                poly[0].y = y0 - (num[i]);

                poly[1].x = x0 + discr_per * (i + 1);
                poly[1].y = y0 - (num[i + 1]);

                Polyline(hdc, poly, 2);
            }

            gotoxy(x0 + 600, y0 + 10);


            // изменение значений шага дискретизайии для удобства рисования графика и вычисления дальнейших значений
            discr_per = 5 * pow(10,-1);          // период дискретизации (0.5)
            double d_per = 5 * pow(10, 0);   
            if (type == "-w")
            {
                d_per = 5 * pow(10, -1);
                discr_per = 5 * pow(10, -4);     // период дискретизации (0.0005)
            }
            else if (type == "-o")
            {
                d_per = 5 * pow(10, -1);
                discr_per = 5 * pow(10, -2);     // период дискретизации (0.05)
            }



            // **************************************************************************************************** //
            //                                      ВЫЧИСЛЕНИЕ ПАРАМЕТРОВ                                           //
            // **************************************************************************************************** //


            int Ua_ind = 0;                 // индекс амплитуды сигнала
            double Ua_num;              // амплитуда сигнала
            int U_a = 0;                // индекс мин амплитуды сигнала
            int max_ind = 0;            // индекс максимальной амплитуды
            int max_Ua = 0;             // значение макс ампл
            int beg_front_ind = 0;          // начало фронта
            int beg_top_ind = 0;            // начало плоской вершины
            int end_top_ind = 0;            // конец плоской вершины
            int beg_cut_ind = 0;            // начало среза
            int end_cut_ind = 0;            // начало среза
            int min_ind = 0;            // индекс мин ампл
            int beg_field = 0;          // начало стабильности значений после мин ампл
            //double min_Ua = 0;          // значение мин ампл
            bool blowout = false;       // наличие выброса




            // порядок вычисления параметров
            // 
            // начало фронта
            // минимальная амплитуда
            // макс амплитуда
            // проверка на наличие выброса
            // начало или конец среза
            // начало плоской вершины
            // конец вершины
            // поле



            int mas = count / 100;              // масштаб вычислений
            if (type == "-w")
            {
                mas = mas / 2;
            }
            else if (type == "-o")
            {
                mas = mas / 2;
            }


            double ave = 0;                      // среднее значение чисел
            bool check;
            double too_m = 0;                    // разница между вершиной и срезом


            // мин и макс числа для сравнений
            double max_num = pow(100, 2) * (-1);
            double min_num = 1000;


            double floor = tan(10 * M_PI / 180);;
            int cc;
            double ang_k;


            // кисточка, которой будут рисоваться точки
            hBrush = CreateSolidBrush(RGB(0, 0, 255));
            SelectObject(hdc, hBrush);
            Pen = CreatePen(PS_SOLID, 3, RGB(0, 0, 255));
            SelectObject(hdc, Pen);


            // нахождение начала фронта
            check = false;
            i = 0;
            // пока коэф наклона между двумя точками меньше tg10, будем продвигаться по графику
            do
            { 
                ang_k = (abs((numbers[i]) - (numbers[i + mas]))) / (discr_per * mas);
                if (ang_k > floor)
                {
                    check = true;
                }
                else
                    i++;
            } while (!check);
            beg_front_ind = i;
            Ellipse(hdc, x0 + d_per * beg_front_ind - rad, y0 - num[beg_front_ind] - rad, x0 + d_per * beg_front_ind + rad, y0 - num[beg_front_ind] + rad);
            


            //// нахождение минимальной амплитуды
            i = beg_front_ind + 1;
            for (i = beg_front_ind + 1; i < count - 1; i++)
            {
                if (num[i] < min_num)
                {
                    min_ind = i;
                    min_num = num[i];
                }
            }


            // нахождение максимальной амплитуды
            i = beg_front_ind + 1;;
            for (i = beg_front_ind + 1; i < min_ind - 1; i++)
            {
                if (num[i] > max_num)
                {
                    max_ind = i;
                    max_num = num[i];
                }
            }

            
            
            // проверка на наличие выброса
            // если нет выброса
            if  (abs(abs(numbers[max_ind]) - abs(numbers[max_ind + mas])) / (discr_per * mas) < floor)
            {
                Ua_ind = max_ind;
                Ua_num = numbers[max_ind];
                max_ind = 0;
            }
            // если был выброс
            if (Ua_ind == 0)
            {
                blowout = true;
                Ellipse(hdc, x0 + d_per * max_ind - rad, y0 - num[max_ind] + rad, x0 + d_per * max_ind + rad, y0 - num[max_ind] - rad);
            }


            // проверка на наличие отрицательного выброса 
            // если мин значение - не выброс
            if ((abs(numbers[min_ind] - numbers[min_ind - mas]) / (discr_per*mas)) < floor)
            {
                if ((abs((numbers[min_ind]) - (numbers[min_ind + mas])) / (discr_per * mas)) < floor)
                {
                    U_a = min_ind;
                    min_ind = count - 1;
                }
            }
            // если был выброс
            if (U_a == 0)
            {
                blowout = true;
                Ellipse(hdc, x0 + d_per * min_ind - rad, y0 - num[min_ind] + rad, x0 + d_per * min_ind + rad, y0 - num[min_ind] - rad);
            }



            // нахождение конца среза, если нет отрицательного выброса
            if (!blowout)
            {
                check = false;
                i = U_a - 1;
                do
                {
                    ang_k = (abs(numbers[i] - numbers[i - mas])) / (discr_per * mas);
                    if (ang_k > floor)
                    {
                        check = true;
                    }
                    else
                        i--;
                } while (!check);
                end_cut_ind = i;
                Ellipse(hdc, x0 + d_per * end_cut_ind - rad, y0 - num[end_cut_ind] - rad, x0 + d_per * end_cut_ind + rad, y0 - num[end_cut_ind] + rad);
                min_ind = end_cut_ind;
            }



            // нахождение начала среза
            check = false;
            i = min_ind - 1;
            do
            {
                ang_k = (abs((numbers[i]) - (numbers[i - mas]))) / (discr_per * mas);
                if (ang_k < floor)
                {
                    check = true;
                }
                else
                    i--;
            } while (!check);
            beg_cut_ind = i+1;
            Ellipse(hdc, x0 + d_per * beg_cut_ind - rad, y0 - num[beg_cut_ind] - rad, x0 + d_per * beg_cut_ind + rad, y0 - num[beg_cut_ind] + rad);


            // если нет выброса
            // нахождение начала плоской вершины
            if (!blowout)
            {
                check = false;
                i = Ua_ind - 1;
                do
                {
                    ang_k = (abs(numbers[i] - numbers[i - mas])) / (discr_per * mas);
                    if (ang_k > floor)
                    {
                        check = true;
                    }
                    else
                        i--;
                } while (!check);
                beg_top_ind = i;
                Ellipse(hdc, x0 + d_per * beg_top_ind - rad, y0 - num[beg_top_ind] - rad, x0 + d_per * beg_top_ind + rad, y0 - num[beg_top_ind] + rad);
            }



            // если есть выброс
            // нахождение начала плоской вершины
            if (blowout)
            {
                check = false;
                i = beg_cut_ind - mas;
                do
                {
                    ang_k = (abs((numbers[i]) - (numbers[i - mas]))) / (discr_per * mas);
                    if (ang_k > floor)
                    {
                        check = true;
                    }
                    else
                        i--;
                } while (!check);
                beg_top_ind = i;
                Ellipse(hdc, x0 + d_per * beg_top_ind - rad, y0 - num[beg_top_ind] - rad, x0 + d_per * beg_top_ind + rad, y0 - num[beg_top_ind] + rad);
            }



            //  нахождение конца плоской вершины
            check = false;
            i = beg_cut_ind - 1;
            do
            {
                ang_k = (abs((numbers[i]) - (numbers[i + mas]))) / (discr_per * mas);
                if (ang_k < floor)
                {
                    check = true;
                }
                else
                    i--;
            } while (!check);
            end_top_ind = i+mas;
            Ellipse(hdc, x0 + d_per * end_top_ind - rad, y0 - num[end_top_ind] - rad, x0 + d_per * end_top_ind + rad, y0 - num[end_top_ind] + rad);




            // если есть выброс, то амплитуда будет смотреться по началу среза
            if (blowout)
            {
                // среднее значений чисел между началом фронта и вершиной
                for (i = beg_front_ind; i < max_ind - 1; i++)
                    too_m = too_m + numbers[i];
                too_m = too_m / (max_ind - beg_front_ind);
                // если разница значений между концом вершины и началом среза слишком большая
                if (abs(numbers[end_top_ind] - numbers[beg_cut_ind]) > too_m)
                {
                    // будем считать, что срез начинается там, где заканчивается вершина
                    beg_cut_ind = end_top_ind;
                }
                Ellipse(hdc, x0 + d_per * beg_cut_ind - rad, y0 - num[beg_cut_ind] - rad, x0 + d_per * beg_cut_ind + rad, y0 - num[beg_cut_ind] + rad);
                Ua_num = numbers[beg_cut_ind];
            }


            // среднее значения чисел, идущих перед фронтом
            ave = 0;
            for (i = 0; i < beg_front_ind; i++)
            {
                ave = ave + abs(numbers[i]);
            }
            ave = ave / beg_front_ind;


            // нахождение ровного участка после мин амплитуды
            // если имеется отрицательный выброс
            if (blowout)
            {
                check = false;
                cc = 0;
                i = min_ind + 1;
                if (type == "-w")
                    mas = mas / 2;
                // пока не найдём ровный участок после мин амплитуды
                do
                {
                    for (j = 0; j < mas; j++)
                    {
                        if (abs(numbers[i+j]) < ave)
                        {
                            cc++;
                        }
                    }
                    if (cc == mas)
                    {
                        check = true;
                    }
                    else
                        i++;
                    cc = 0;
                } while (!check);
                beg_field = i;
                Ellipse(hdc, x0 + d_per * beg_field - rad, y0 - num[beg_field] - rad, x0 + d_per * beg_field + rad, y0 - num[beg_field] + rad);
                if (type == "-w")
                    mas = mas * 2;
            }



            // выводимые точки

            cout << "отображаемые точки:" << endl;
            if (blowout)
            {
                cout << "1) начало фронта\n2) выброс с максимальным значением амплитуды\n3) начало плоской вершины\n4) конец плоской вершины\n5) начало среза\n"
                    << "6) выброс с минимальных значением амплитуды\n\n";
            }
            else
            {
                cout << "есть выбросы\n1) начало фронта\n2) начало плоской вершины\n3) конец плоской вершины\n4) начало среза\n"
                    << "5) конец среза\n\n";
                min_ind = 0;
            }


            cout << "название\tномер точки\tзначение:\n";
            //// выводы
            cout << "начало фронта\t" << beg_front_ind << "\t\t" << numbers[beg_front_ind] <<  endl;
            //cout << i << "\t" << numbers[i] << "\t" << numbers[i + 1] << "\t" << ang_k << endl;
            if (!blowout)
            {
                cout << "выброс (макс)\t-" << "\t\t   -" << endl;
            }
            else
                cout << "выброс (макс)\t" << max_ind << "\t\t" << numbers[max_ind] << endl;
            cout << "начало вершины\t" << beg_top_ind << "\t\t" << numbers[beg_top_ind] << endl;
            cout << "конец вершины\t" << end_top_ind << "\t\t" << numbers[end_top_ind]  << endl;
            cout << "начало среза\t" << beg_cut_ind << "\t\t" << numbers[beg_cut_ind] << endl;
            if (!blowout)
            {
                cout << "выброс (мин)\t-"  << "\t\t   -" << endl;
                cout << "конец среза\t" << end_cut_ind << "\t\t" << numbers[end_cut_ind] << endl;
            }
            else
                cout << "выброс (мин)\t" << min_ind << "\t\t" << numbers[min_ind] << endl;
            cout << endl;






            // **************************************************************************************************** //
            //                                           ВЫВОД ПАРАМЕТРОВ                                           //
            // **************************************************************************************************** //



            double part_01 = Ua_num * 0.1;
            double part_09 = Ua_num * 0.9;      
            double part_05 = Ua_num * 0.5;
            double AUn;                 
            double AU_n;                
            double time_front = 0;              // длительность фронта
            double time_work = 0;               // длительность работы сигнала
            double time_cut = 0;                // длительность среза
            double time_fr_out = 0;             // длительность выброса по переднему фронту
            double time_cut_out = 0;            // длительность выброса по заднему фронту
            int r = 0;
            int Un = 0;                         // ампл помехи (наибольшей после min)
            int U_n = 0;                        // ампл помехи (наименьшей после max)
            string mach;
            mach = " *10^(-9) c";

            if (type == "-j")
            {
                discr_per = discr_per * pow(10,0);

            }
            else if (type == "-w")
            {
                discr_per = discr_per * pow(10, 4);
            }
            else if (type == "-o")
            {
                discr_per = discr_per * pow(10, 2);
            }

            //AUn = (Ua_num - num[Un]) / k;
            //AU_n = num[U_n] ;


            cout << "\nвывод параметров:\n\n";
            

            // длительность фронта
            while (numbers[r] < part_01)
            {
                r++;
            }
            while ((numbers[r] >= part_01) && (numbers[r] <= part_09) && (r < count - 1))
            {
                time_front = time_front + discr_per;
                r++;
            }
            cout << "длительность фронта:\t"  << time_front << mach << endl;


            // длительность среза
            r = end_top_ind;
            while (numbers[r] > part_09)
            {
                r++;
            }
            while ((numbers[r] >= part_01) && (numbers[r] <= part_09) && (r < count - 1))
            {
                time_cut = time_cut + discr_per;
                r++;
            }
            cout << "длительность среза:\t"  <<  time_cut << mach << endl;


            // длительность работы сигнала
            r = beg_front_ind;
            while (numbers[r] < part_05)
            {
                r++;
            }
            while ((numbers[r] >= part_05) && (r < count - 1))
            {
                time_work = time_work + discr_per;
                r++;
            }
            cout << "длительность работы сигнала:\t"  <<  time_work << mach << endl;



            // длительность выброса по переднему фронту
            r = beg_front_ind;
            while (numbers[r] < part_09)
            {
                r++;
            }
            while ((r < beg_top_ind) && (r < count - 1))
            {
                time_fr_out = time_fr_out + discr_per;
                r++;
            }
            cout << "длительность выброса по переднему фронту:   " << time_fr_out << mach << endl;


            // длительность выброса по заднему фронту
            r = beg_cut_ind;
            while (numbers[r] > part_01)
            {
                r++;
            }
            while ((r < beg_field) && (r < count - 1))
            {
                time_cut_out = time_cut_out + discr_per;
                r++;
            }
            cout << "длительность выброса по заднему фронту:\t" <<  time_cut_out << mach << endl;



            // аплитуды помех
            if (blowout)
            {
                //отрицательной
                double U_n_min = numbers[max_ind];
                for (i = max_ind + 1; i < beg_top_ind; i++)
                {
                    if (numbers[i] < U_n_min)
                    {
                        U_n_min = numbers[i];
                        U_n = i;
                    }
                }

                // положительной
                double Un_max = numbers[min_ind];
                for (i = min_ind + 1; i < beg_field; i++)
                {
                    if (numbers[i] > Un_max)
                    {
                        Un_max = numbers[i];
                        Un = i;
                    }
                }
                cout << "амплитуда положительной помехи\nUn = " << numbers[Un] << "\t" 
                     << "\nамплитуда отрицательной помехи\nU_n = " << numbers[U_n] << endl;
            }
            else 
            {
                cout << "there is no blowout\n";
                cout << "амплитуда положительной помехи\nUn = " << numbers[Un] << "\t"
                    << "амплитуда положительной помехи\nU_n = " << numbers[U_n] << endl;
            }


            double Ub01 = (numbers[max_ind] - Ua_num);                                  // амплитуда выброса по переднему фронту
            double Ub10 = numbers[min_ind];                                             // амплитуда выброса по заднему фронту
            cout << "амплитуда выброса по переднему фронту\nUb01 = " << Ub01 
                 << "\nамплитуда выброса по заднему фронту\nUb10 = " << Ub10 << endl;


        }
    }//end if





    return 0;
}
