#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <cmath>
#include <windows.h>
#include "ConWin.h"
#include <process.h>


using namespace std;
extern HDC hdc; // объявим  контекст устройства

HDC hdc;	// Объявим контекст устройства
            // Контекст устройства по сути это структура,
            // содержащая описание видеокарты на вашем компьютере
            // и всех необходимых графических элементов



// размеры окна для графика
const int kolvo = 200;
const double discr_per = 5 * pow(10, -9) * pow(10, 9);   // период дискретизации (5)
const int k = 30;

int main(int argc, const char* argv[])
{

    ifstream inputFile("C:\\Users\\User\\Desktop\\практика\\просто_тесты\\1.txt"); //чтение из файла
    // если не существует этого файла
    if (!inputFile)
    {
        //вывод об ошибке
        cerr << "Error! Not exist!" << endl;
        return 1;
    }


    string test;
    getline(inputFile, test);   //перенос всего содержимого в одну строку
    inputFile.close();          //закрытие файла

    // Удаляем скобки
    // если первым символом явдяется скобка
    if (test.front() == '[')
    {
        test.erase(0, 1);
    }
    // если последним символом явдяется скобка
    if (test.back() == ']')
    {
        test.pop_back();
    }

    vector<double> numbers;     // вектор чисел
    stringstream str(test);     // переменная для перевода строки в набор чисел
    string number;

    while (getline(str, number, ','))       // вычленение чисел из строки, разделённых запятой
    {
        // добавление нового числа в конец вектора чисел
        numbers.push_back(stod(number));
    }

    int count = numbers.size();
    int i, j;
    cout << count << endl;
    cout << "Numbers:" << endl;
    for (i = 0; i < count; i++)
    {
        //cout << i << "\t" << numbers[i] << endl;
        numbers[i] = numbers[i] * k;
    }
    //for (i = 0; i < 10; i++)
    //{
    //    cout << i << "\t" << numbers[i] << endl;
    //}
    //for (i = 0; i < 45; i++)
    //{
    //    cout << endl;
    //}


    //получим дескриптор консольного окна
    HWND hwnd = GetConcolWindow();

    //если дескриптор существует
    if (hwnd != NULL)
    {
        //получим контекст устройства для консольного окна
        hdc = GetWindowDC(hwnd);

        //если контекст существует - можем работать
        if (hdc != 0)
        {
            int colR = 255;
            int colG = 0;
            int colB = 0;
            double x0 = 350;
            double y0 = 370;
            int rad = 5;

            POINT coordX[2];
            POINT coordY[2];
            coordX[0].x = x0;
            coordX[0].y = y0;
            coordX[1].x = x0 + 1200;
            coordX[1].y = y0;

            coordY[0].x = x0;
            coordY[0].y = y0 + 300;
            coordY[1].x = x0;
            coordY[1].y = y0 - 400;

            Polyline(hdc, coordX, 2);
            Polyline(hdc, coordY, 2);

            HPEN Pen = CreatePen(PS_SOLID, 3, RGB(colR, colG, colB));
            SelectObject(hdc, Pen);
            HBRUSH hBrush = CreateSolidBrush(RGB(colR, colG, colB));
            SelectObject(hdc, hBrush);


            POINT poly[2];
            for (int i = 0; i < count - 1; i++)
            {
                poly[0].x = x0 + discr_per * i;
                poly[0].y = y0 - (numbers[i] );

                poly[1].x = x0 + discr_per * (i + 1);
                poly[1].y = y0 - (numbers[i + 1] );

                Polyline(hdc, poly, 2);
            }

            cout << "OK_1" << endl;
            for (i = 0; i < 15; i++)
            {
                cout << endl;
            }

            int Ua = 0;                 // индекс амплитуды сигнала
            double Ua_num;              // амплитуда сигнала
            int U_a = 0;                 // индекс амплитуды сигнала
            int max_ind = 0;
            int max_Ua = 0;
            int beg_front = 0;
            int beg_top = 0;
            int end_top = 0;
            int beg_cut = 0;
            int end_cut = 0;
            int beg_per = 0;
            int min_ind = 0;
            int beg_field = 0;
            double min_Ua = 0;
            double time_front = 0;
            double time_work = 0;
            double time_cut = 0;
            int max_num_back = 0;
            int period;

            // начало фронта
            // макс амплитуда
            // проверка на наличие выброса
            // начало плоской вершины
            // конец вершины
            // начало среза
            // минимальная амплитуда
            // конец среза

            vector<double> pg[20];         // вектор максимальных отклонений



            double pog = 2.5;               // допустимая разница
            double max_num = pow(1, -6);
            double min_num = 1000;
            double dif = 1000;


            hdc = GetWindowDC(hwnd);
            hBrush = CreateSolidBrush(RGB(0, 0, 255));
            SelectObject(hdc, hBrush);
            // нахождение начала фронта
            i = 0;
            double d = 0;

            for (i = 0; i < count/2 - 1; i++)
            {
                if (abs(abs(numbers[i]) - abs(numbers[i + 1])) > d)
                    d = abs(abs(numbers[i]) - abs(numbers[i + 1]));
                //cout << i << "\t" << abs(abs(numbers[i]) - abs(numbers[i + 1])) << endl;
            }
            cout << d << endl;

            i = 0;
            while ((abs(abs(numbers[i]) - abs(numbers[i + 1])) < pog) && (i < count/2 - 1))
            {
                //cout << i << "\t" << abs(abs(numbers[i]) - abs(numbers[i + 1])) << endl;
                i++;
            }
            beg_front = i;
            cout << "beg of front\n" << beg_front << "\t" << numbers[beg_front] << "\t" << numbers[beg_front + 1] << endl;
            i++;
            Ellipse(hdc, x0 + discr_per * beg_front - rad, y0 - numbers[beg_front] - rad, x0 + discr_per * beg_front + rad, y0 - numbers[beg_front] + rad);


            // нахождение максимальной амплитуды
            while ((numbers[i + 1] > numbers[i]) && (i < count - 1))
            {
                i++;
            }
            max_ind = i;
            cout << "max index\n" << max_ind << "\t" << numbers[max_ind] << endl;
            i++;
            Ellipse(hdc, x0 + discr_per * max_ind - rad, y0 - numbers[max_ind] + rad, x0 + discr_per * max_ind + rad, y0 - numbers[max_ind] - rad);


            // проверка на наличие выброса
            if (((numbers[max_ind] - numbers[max_ind + 1]) < pog) &&
                ((numbers[max_ind+1] - numbers[max_ind + 2]) < pog) &&
                ((numbers[max_ind+2] - numbers[max_ind + 3]) < pog))
            {
                // если последующие значения справа от макс отличаются незначительно
                // то макс значение - просто амплитуда
                Ua = max_ind;
            }
            else
            {
                // иначе - макс значение - это выброс
                max_Ua = max_ind;
            }
            // у нас теперь есть либо амплитуда, либо выброс

            // если был выброс
            if (Ua == 0)
            {
                Ua_num = numbers[beg_cut];
                cout << "there is an outlier" << endl;
            }
            else
            {
                Ua_num = numbers[Ua];
            }


            // если был выброс, то теперь нужно найти амплитуду
            // для этого найдем начало среза
            i = max_ind+1;
            bool top = false;
            int cc = 0;
            pog = 1;
            do
            {
                for (int j = 0; j < 30; j++)
                {
                    if (abs(abs(numbers[i + j]) - abs(numbers[i + j + 1])) < pog)
                    {
                        cc++;
                    }
                }
                if (cc == 30)
                {
                    top = true;
                }
                i++;
                cc = 0;

            } while (!top);
            // начало плоcкой вершины
            beg_top = i;
            cout << "beg of top\n" << beg_top << "\t" << numbers[beg_top] << endl;
            Ellipse(hdc, x0 + discr_per * beg_top - rad, y0 - numbers[beg_top] - rad, x0 + discr_per * beg_top + rad, y0 - numbers[beg_top] + rad);
            i = 0;

            pog = 18;
            //// поиск ещё одного большого значения
            //for (i = beg_top+1; i < count-1; i++)
            //{
            //    if (numbers[i] > max_num)
            //    {
            //        max_num = numbers[i];
            //        max_num_back = i;
            //    }
            //}
            //if (abs(max_num_back - max_num) < pog)
            //{
            //    cout << "max num_back index\n" << max_num_back << "\t" << numbers[max_num_back] << endl;
            //    Ellipse(hdc, x0 + discr_per * max_num_back - rad, y0 - numbers[max_num_back] - rad, x0 + discr_per * max_num_back + rad, y0 - numbers[max_num_back]  + rad);
            //    period = max_num_back - max_ind;
            //    cout << "period:\n" << period << "\t" << numbers[period - 1] << "   " << numbers[period] << "   " << numbers[period + 1] << endl;
            //    Ellipse(hdc, x0 + discr_per * period - rad, y0 - numbers[period] - rad, x0 + discr_per * period + rad, y0 - numbers[period] + rad);
            //}
            //else
            //{
            //    cout << "there is no period" << endl;
            //    period = count - 1;
            //}


            i = beg_top;
            while ((abs(abs(numbers[i]) - abs(numbers[i + 1])) < pog) && (i < count - 1))
            {
                //cout << abs(abs(numbers[i]) - abs(numbers[i + 1])) << endl;
                i++;
            }
            // конец плоской вершины => следующее значение - начало среза
            end_top = i;
            cout << "end of top\n" << end_top << "\t" << numbers[end_top] << "\t" << numbers[end_top+1] << endl;
            i++;
            Ellipse(hdc, x0 + discr_per * end_top - rad, y0 - numbers[end_top]  - rad, x0 + discr_per * end_top + rad, y0 - numbers[end_top]  + rad);

            beg_cut = i;
            cout << "beg of cut\n" << beg_cut << "\t" << numbers[beg_cut] << endl;
            Ellipse(hdc, x0 + discr_per * beg_cut - rad, y0 - numbers[beg_cut]  - rad, x0 + discr_per * beg_cut + rad, y0 - numbers[beg_cut]  + rad);




            //// нахождение минимальной амплитуды
            //for (i = beg_cut; i < period; i++)
            //{
            //    if (numbers[i] < min_num)
            //    {
            //        min_ind = i;
            //        min_num = numbers[i];
            //    }
            //}
            //cout << "min index\n" << min_ind << "\t" << numbers[min_ind] << endl;
            //i++;
            //Ellipse(hdc, x0 + discr_per * min_ind - rad, y0 - numbers[min_ind] * k + rad, x0 + discr_per * min_ind + rad, y0 - numbers[min_ind] * k - rad);

            //// проверка на наличие отрицательного выброса
            //if (((numbers[min_ind] - numbers[min_ind + 1]) < pog) &&
            //    ((numbers[min_ind + 1] - numbers[min_ind + 2]) < pog) &&
            //    ((numbers[min_ind + 2] - numbers[min_ind + 3]) < pog))
            //{
            //    // если последующие значения справа от макс отличаются незначительно
            //    // то макс значение - просто амплитуда
            //    U_a = min_ind;
            //}
            //else
            //{
            //    // иначе - макс значение - это выброс
            //    min_ind = count - 1;
            //}
            //// у нас теперь есть либо амплитуда, либо выброс

            //// если был выброс
            //if (U_a == 0)
            //{
            //    cout << "there is an min outlier" << endl;
            //}


            //for (i = beg_cut; i < min_ind; i++)
            //{
            //    if (abs(0 - numbers[i]) < dif)
            //    {
            //        dif = abs(0 - numbers[i]);
            //        end_cut = i;
            //    }
            //}
            ////i = beg_cut;
            ////while (abs(numbers[i]) > 0.1)
            ////{
            ////    i++;
            ////}
            ////end_cut = i;
            //cout << "end_cut\n" << end_cut << "\t" << numbers[end_cut] << endl;
            //i++;
            //Ellipse(hdc, x0 + discr_per * end_cut - rad, y0 - numbers[end_cut] * k + rad, x0 + discr_per * end_cut + rad, y0 - numbers[end_cut] * k - rad);



            //i = min_ind+1;
            //while ((abs(abs(numbers[i]) - abs(numbers[i + 1])) > pog) ||
            //    (abs(abs(numbers[i + 1]) - abs(numbers[i + 2])) > pog) ||
            //    (abs(abs(numbers[i + 2]) - abs(numbers[i + 3])) > pog))
            //{
            //    i++;
            //}
            //// начало плоcкой вершины
            //beg_field = i;
            //cout << "beg of field\n" << beg_field << "\t" << numbers[beg_field] << endl;
            //Ellipse(hdc, x0 + discr_per * beg_field - rad, y0 - numbers[beg_field] * k - rad, x0 + discr_per * beg_field + rad, y0 - numbers[beg_field] * k + rad);
            //i = 0;


            //////i = 0;
            //////while ((abs(abs(numbers[i]) - abs(numbers[i])) < pog) && (i < count - 1))
            //////{
            //////    i++;
            //////}
            //////beg_front = i;
            //////cout << "beg of front\n" << beg_front << "\t" << numbers[beg_front] << endl;
            //////i++;

            ////double part_01 = Ua_num * 0.1;
            ////double part_09 = Ua_num * 0.9;
            ////int r = 0;
            ////int t_f_c = 0;
            ////while (numbers[r] < part_01)
            ////{
            ////    r++;
            ////}
            ////while ((numbers[r] >= part_01) && (numbers[r] <= part_09) && (r < count - 1))
            ////{
            ////    time_front = time_front + discr_per;
            ////    t_f_c++;
            ////    r++;
            ////}
            ////cout << "time of front\n" << r << "\t" << t_f_c << "\t" << time_front << endl;

        }
    }//end if

  



    return 0;
}
